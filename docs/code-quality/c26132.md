---
# Required metadata
# For more information, see https://review.learn.microsoft.com/en-us/help/platform/learn-editor-add-metadata?branch=main
# For valid values of ms.service, ms.prod, and ms.topic, see https://review.learn.microsoft.com/en-us/help/platform/metadata-taxonomies?branch=main

title: Warning C26132
description: Documentation on static analysis warning C26132
author:      Rastaban # GitHub alias
ms.author:   philc # Microsoft alias
ms.service: visual-cpp
ms.topic: article
ms.date:     02/11/2025
---
# Warning C26132

> Variable '*variable name*' should be protected by '*lock 1*', but '*lock 2*' is held instead. Possible annotation mismatch.

Warning C26132 is issued when the analyzer detects that the lock that is annotated to protect a value is not held when the value is accessed. However, another lock that appears to be related is held. It is possible the code is thread safe, and the annotations need to be updated.

## Examples

In the following example, C26132 is emitted when `data` is used.

> warning C26132: Variable 'data' should be protected by 'customLock01', but '(&customLock01)->cs' is held instead. Possible annotation mismatch.

 The variable `data` is annotated to be protected by `customLock01`, but the locking function `CustomLockAcquire` is annotated to acquire the related lock `customLock01->cs`.

```cpp
#include <sal.h>
struct CustomLock {
    int cs; // "Critical Section" lock
};

_Acquires_exclusive_lock_(criticalSection->cs) // notice the `->` indirection
void CustomLockAcquire(CustomLock* criticalSection);

_Releases_lock_(criticalSection->cs) // notice the `->` indirection
void CustomLockRelease(CustomLock* criticalSection);

// global lock
CustomLock customLock01;

void Initialize(_Guarded_by_(customLock01) int* data)
{
    CustomLockAcquire(&customLock01);
    *data = 1; // C26132
    CustomLockRelease(&customLock01);
}
```

In this example the `Initialize` function is thread safe and behaves as designed, but that design is not correctly reflected in the concurrency SAL annotations. This is fixed by adjusting the annotations on the custom locking functions to use `criticalSection` rather than `criticalSection->cs`. This could also be fixed by changing the `_Guarded_by_` annotation from `customLock01` to `customLock01.cs`.

```cpp
#include <sal.h>
struct CustomLock {
    int cs; // "Critical Section" lock
};

_Acquires_exclusive_lock_(criticalSection)
void CustomLockAcquire(CustomLock* criticalSection);

_Releases_lock_(criticalSection)
void CustomLockRelease(CustomLock* criticalSection);

// global lock
CustomLock customLock01;

void Initialize(_Guarded_by_(customLock01) int* data)
{
    CustomLockAcquire(&customLock01);
    *data = 1;
    CustomLockRelease(&customLock01);
}
```

