---
# Required metadata
# For more information, see https://review.learn.microsoft.com/en-us/help/platform/learn-editor-add-metadata?branch=main
# For valid values of ms.service, ms.prod, and ms.topic, see https://review.learn.microsoft.com/en-us/help/platform/metadata-taxonomies?branch=main

title: Warning C26133
description: Documentation on static analysis warning C26133
author:      Rastaban # GitHub alias
ms.author:   philc # Microsoft alias
ms.service: visual-cpp
ms.topic: article
ms.date:     02/11/2025
---
# Warning C26133

> Caller failing to hold lock '*lock 1*' before calling function '*function name*', but '*lock 2*' is held instead. Possible annotation mismatch.

Warning C26133is issued when the analyzer detects that the lock that is required to call a function, is not held when the function is called. However, another lock that appears to be related is held. It is possible the code is thread safe, and the annotations need to be updated.

## Examples

In the following example, C26133 is emitted when `DoTaskWithCustomLock` is called.

>  warning C26133: Caller failing to hold lock 'customLock01' before calling function 'DoTaskWithCustomLock', but '(&customLock01)->cs' is held instead. Possible annotation mismatch.

```cpp
#include <sal.h>

struct CustomLock {
    int cs; // "Critical Section"
};

_Acquires_exclusive_lock_(criticalSection->cs) // notice the `->` indirection
void CustomLockAcquire(CustomLock* criticalSection);

_Releases_lock_(criticalSection->cs) // notice the `->` indirection
void CustomLockRelease(CustomLock* criticalSection);

CustomLock customLock01;

_Requires_lock_held_(customLock01) void DoTaskWithCustomLock();

void DoTask()
{
    CustomLockAcquire(&customLock01);
    DoTaskWithCustomLock(); // C26133
    CustomLockRelease(&customLock01);
}
```

In this example the `DoTask` function is thread safe and behaves as designed, but that design is not correctly reflected in the concurrency SAL annotations. This is fixed by adjusting the annotations on the custom locking functions to use `criticalSection` rather than `criticalSection->cs`. This could also be fixed by changing the `_Requires_lock_held_` annotation from `customLock01` to `customLock01.cs`.

```cpp
#include <sal.h>

struct CustomLock {
    int cs; // "Critical Section"
};

_Acquires_exclusive_lock_(criticalSection)
void CustomLockAcquire(CustomLock* criticalSection);

_Releases_lock_(criticalSection)
void CustomLockRelease(CustomLock* criticalSection);

CustomLock customLock01;

_Requires_lock_held_(customLock01) void DoTaskWithCustomLock();

void DoTask()
{
    CustomLockAcquire(&customLock01);
    DoTaskWithCustomLock();
    CustomLockRelease(&customLock01);
}
```