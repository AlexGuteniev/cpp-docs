---
# Required metadata
# For more information, see https://review.learn.microsoft.com/en-us/help/platform/learn-editor-add-metadata?branch=main
# For valid values of ms.service, ms.prod, and ms.topic, see https://review.learn.microsoft.com/en-us/help/platform/metadata-taxonomies?branch=main

title: Warning C26838
description: '"Describes the Microsoft C/C++ code analysis warning C26838, its causes, and how to address it."'
author:      Rastaban # GitHub alias
ms.author:   philc # Microsoft alias
ms.service: visual-cpp
ms.topic: reference
ms.date:     08/22/2024
---
# Warning `C26839`

> Allocation size is the result of a signed to unsigned narrowing conversion that could result in overflow if the signed value is negative

## Remarks

This warning reports that the size specified for an allocation may be the result of the conversion of a possibly negative signed value to an unsigned value. For example:

```cpp
void* CustomAlloc(size_t);

int* CreateIntArray(int numberOfElements)
{
    int* p = (int*)CustomAlloc(numberOfElements * sizeof(int)); // Warning: C26838
    // ...
    return p;
}
```

In the expression `numberOfElements * sizeof(int)`, `numberOfElements` is signed and `sizeof(int)` is unsigned. On 64 bit machines `numberOfElements` will be promoted to an unsigned value when multiplied
by `sizeof(int)`. When `numberOfElements` is negative, the resulting value may overflow or have unexpected results when passed to `CustomAlloc`.

This check applies to common allocation functions like `new`, `malloc`, and `VirtualAlloc`. The check also applies to custom allocator functions that have `alloc` (case insensitive) in the function name.

This check sometimes fails to recognize that certain checks can prevent overflows because the check is conservative.

This warning is available in Visual Studio 2022 version 17.12 and later versions.

## Example

To fix the previous code example in which `numberOfElements * sizeof(int)` might overflow due to a negative signed value, introduce a check to make sure it won't. For example:

```cpp
void* CustomAlloc(size_t);

int* CreateIntArray(int numberOfElements)
{
    if (numberOfElements < 0)
        return nullptr;

    int* p = (int*)CustomAlloc(numberOfElements * sizeof(int));
    // ...
    return p;
}
```

In the previous example, checking for a negative value addresses the C26832 warning. Depending on the size of the types involved, this check may result in a different warning such as [`C26831`](c26831.md).
For example, on a 32 bit system, both `int` and `size_t` are 32 bits, so the result of the multiplication can still overflow without negative values.

## See also

[`C26831`](c26831.md)\
[`C26832`](c26832.md)\
[`C26833`](c26833.md)\
[`C26833`](c26839.md)

